{"0": {
    "doc": "Page not found",
    "title": "Page not found",
    "content": "The page you’re looking for does not exist. Status Code: 404 . ",
    "url": "/404.html",
    "relUrl": "/404.html"
  },"1": {
    "doc": "Agent",
    "title": "Agent",
    "content": "An agent actually pings targets to check if their status is OK or not. The way an agent works is: . | It receives the check from the central server through the gRPC API. | Each agent has a manager. Manager adds a controller which runs the check at regular intervals of time. | Another controller is created with all the agents which is responsible for updating the database with metrics at regular intervals. | At regular intervals of time, agent exports metrics to the database. Along with the metrics, agent is also responsible to send alerts. | . Elements of an agent are pluggable. An agent can support multiple types of checkers (TCP, DNS, HTTP etc.), various databases (TimescaleDB, Prometheus) and alerts (Mail, Slack, Discord etc.) . ",
    "url": "/architecture/agent.html",
    "relUrl": "/architecture/agent.html"
  },"2": {
    "doc": "Agent",
    "title": "Standalone",
    "content": "An agent can also work in standalone mode. This means, an agent can be configured with a config file and will run independently without any requirement of it being registered with the app database. ",
    "url": "/architecture/agent.html#standalone",
    "relUrl": "/architecture/agent.html#standalone"
  },"3": {
    "doc": "Agent",
    "title": "Metrics",
    "content": "Metrics are stored in a different database than the application database. This has some benefits: . | Since metrics are very often updated, this database can be scaled. | Metrics databases are pluggable. Being independent of the main database, user can plug in a variety of databases. | Allows standalone mode to work completely independently. | . ",
    "url": "/architecture/agent.html#metrics",
    "relUrl": "/architecture/agent.html#metrics"
  },"4": {
    "doc": "Agent",
    "title": "Alerts",
    "content": "When inserting metrics into database, agent checks if the check previously was successful or not. If the status of last check and current check changes, it sends an alert. ",
    "url": "/architecture/agent.html#alerts",
    "relUrl": "/architecture/agent.html#alerts"
  },"5": {
    "doc": "Agent",
    "title": "Page",
    "content": "An independent page can be created due to this architecture. Exporters responsible for inserting metrics in the database can also fetch metrics from the database. Agent offers a simple API endpoint through which metrics can be fetched and a status page can be created. ",
    "url": "/architecture/agent.html#page",
    "relUrl": "/architecture/agent.html#page"
  },"6": {
    "doc": "Building from source",
    "title": "Building from source",
    "content": "Pinger is written purely in Go but is dependent on a few other external dependencies. ",
    "url": "/development/building-from-source.html",
    "relUrl": "/development/building-from-source.html"
  },"7": {
    "doc": "Building from source",
    "title": "Prerequisites",
    "content": "Before beginning make sure you have all the required tools installed. | Go &gt;= 1.3 (Preferred &gt;= 1.5) | PostgreSQL &gt;= 11 (Preferred &gt;= 12) | Timescale &gt;= 1.7 | Docker &gt;= 17.05 | . ",
    "url": "/development/building-from-source.html#prerequisites",
    "relUrl": "/development/building-from-source.html#prerequisites"
  },"8": {
    "doc": "Building from source",
    "title": "Setup",
    "content": ". | Clone the repository and change-directory to it. $ git clone git@github.com/sdslabs/pinger.git $ cd pinger . | Build the project as ./target/pinger. $ make build . | Verify a successful build by pinging it. $ ./target/pinger ping INFO[0000] pong . | . ",
    "url": "/development/building-from-source.html#setup",
    "relUrl": "/development/building-from-source.html#setup"
  },"9": {
    "doc": "Central Controller",
    "title": "Central controller",
    "content": "Central component is present for assigning checks to agents. Since there can be multiple agents across many machines, there is a need for a central entity to resolve which agent should get which check. ",
    "url": "/architecture/central-controller.html#central-controller",
    "relUrl": "/architecture/central-controller.html#central-controller"
  },"10": {
    "doc": "Central Controller",
    "title": "How it works",
    "content": "Central controller watches for changes in the database. If a check is created or deleted or updated, it assigns or removes the check from the corresponding agent. The checks are assigned to the agent with the minimum number of checks at a given instance of time. Since it’s rare for state of a check to update often, this approach works. Agents are registered with the database, which central controller watches. Similar to checks, it manages agents. If an agent is deleted, it’s checks are reassigned to another agent. At any point there has to be atleast one agent. The controller caches state of checks and agents in memory for quick access. ",
    "url": "/architecture/central-controller.html#how-it-works",
    "relUrl": "/architecture/central-controller.html#how-it-works"
  },"11": {
    "doc": "Central Controller",
    "title": "Central Controller",
    "content": " ",
    "url": "/architecture/central-controller.html",
    "relUrl": "/architecture/central-controller.html"
  },"12": {
    "doc": "Client and App server",
    "title": "Client and App server",
    "content": "The client is what the user sees. It’s the frontend of the application. Client interacts with the app server to do tasks such as: . | Register or Login | Create checks and status pages | Update incident status | Add alerts to checks | . This happens through the REST API provided by the app server. The only job of App server is to do all the CRUD operations of the application. After receiving a request, it authenticates, authorizes and updates the app database. ",
    "url": "/architecture/client-and-app-server.html",
    "relUrl": "/architecture/client-and-app-server.html"
  },"13": {
    "doc": "Directory structure",
    "title": "Directory structure",
    "content": ". ├── cmd │   └── pinger ├── docs ├── pkg ├── target └── vendor . ",
    "url": "/development/directory-structure.html",
    "relUrl": "/development/directory-structure.html"
  },"14": {
    "doc": "Directory structure",
    "title": "Root",
    "content": "Root directory contains all the build related files or the meta-data for the project/repository. It contains files varying from project’s Dockerfile to linter config .golangci.yml. ",
    "url": "/development/directory-structure.html#root",
    "relUrl": "/development/directory-structure.html#root"
  },"15": {
    "doc": "Directory structure",
    "title": "Command line",
    "content": "cmd/ contains the commands that can be executed using the binary. It is the building block package for the Pinger CLI. cmd/pinger/ contains the main (or entry-point) for the CLI. ",
    "url": "/development/directory-structure.html#command-line",
    "relUrl": "/development/directory-structure.html#command-line"
  },"16": {
    "doc": "Directory structure",
    "title": "Documentation",
    "content": "docs/ contains the documentation for the project. Documentation is generated using the Jekyll framework. To know more see how to build documentation. ",
    "url": "/development/directory-structure.html#documentation",
    "relUrl": "/development/directory-structure.html#documentation"
  },"17": {
    "doc": "Directory structure",
    "title": "Target",
    "content": "target/ contains any of the builds, including libraries and binaries for the project. ",
    "url": "/development/directory-structure.html#target",
    "relUrl": "/development/directory-structure.html#target"
  },"18": {
    "doc": "Directory structure",
    "title": "Vendor",
    "content": "vendor/ contains the source code of dependencies of the project. See vendoring for more details. ",
    "url": "/development/directory-structure.html#vendor",
    "relUrl": "/development/directory-structure.html#vendor"
  },"19": {
    "doc": "Documentation",
    "title": "Documentation",
    "content": "It’s appericiated that you document features or release changes along-with your code change itself. ",
    "url": "/development/documentation.html",
    "relUrl": "/development/documentation.html"
  },"20": {
    "doc": "Documentation",
    "title": "Building documentation",
    "content": "We use Jekyll to generate the documentation. Prerequisites . Make sure you have these installed before you can build docs. | Ruby &gt;= 2.6 | Bundler | . Build . | Install dependencies: $ make docs-install . | Build documentation: $ make docs-build . | . Tip The above steps can be done together using make docs. When developing it’s helpful to build on file change. # Build in watch mode $ make docs-watch # Serve documentation on :4000 $ make docs-serve . ",
    "url": "/development/documentation.html#building-documentation",
    "relUrl": "/development/documentation.html#building-documentation"
  },"21": {
    "doc": "Development",
    "title": "Development",
    "content": "Here you’ll find how you can make changes to the source code of the application. ",
    "url": "/development/",
    "relUrl": "/development/"
  },"22": {
    "doc": "Architecture",
    "title": "Architecture Overview",
    "content": "Pinger is made of four major components – client, app server, central controller and agent. Before we dig deep into the architecture, we should become familiar with the following keywords: . | Keyword | What it is | . | Check | Anything that can be pinged. Say, pinging google.com using HTTP protocol and checking for status code 200. | . | Metric | Result of a ping. Whether google.com returned status 200 in reasonable time or not. | . | Controller | Something that runs a specific task again and again at regular intervals of time. | . | Manager | Manages multiple controllers together and collects statistics from each of them. | . | Page (Status Page) | A collection of various checks and their corresponding metrics. | . The basic idea: the client adds checks by requesting the app server. The app server adds the checks to database. Central controller watches for changes in the database and assigns the check to one of the agents registered with the application. Each component has more work than what can be seen from the diagram above. To know more, let’s dive into each component individually. ",
    "url": "/architecture/#architecture-overview",
    "relUrl": "/architecture/#architecture-overview"
  },"23": {
    "doc": "Architecture",
    "title": "Architecture",
    "content": " ",
    "url": "/architecture/",
    "relUrl": "/architecture/"
  },"24": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Pinger is an open-source implementation of an application that can create status pages. Some similar applications are Freshping and Apex Ping. ",
    "url": "/#introduction",
    "relUrl": "/#introduction"
  },"25": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "Project is currently under active development. If you’re a developer, head over to the developer documentation. ",
    "url": "/",
    "relUrl": "/"
  },"26": {
    "doc": "Making changes",
    "title": "Making changes to the codebase",
    "content": "These are a few guidelines that need to be followed in-order to make changes in the main repository. ",
    "url": "/development/making-changes.html#making-changes-to-the-codebase",
    "relUrl": "/development/making-changes.html#making-changes-to-the-codebase"
  },"27": {
    "doc": "Making changes",
    "title": "Vendoring",
    "content": "We vendor all the dependencies of our project. All the dependencies are listed in go.mod file and are maintained in the vendor/ directory. When updating or adding or deleting a dependency, run the following to keep the vendor up-to-date: . $ make vendor . ",
    "url": "/development/making-changes.html#vendoring",
    "relUrl": "/development/making-changes.html#vendoring"
  },"28": {
    "doc": "Making changes",
    "title": "Protobufs",
    "content": "To install protobuf compiler, and other development tools, use: . $ make install . Run the following to compile protobufs: . $ make proto . When making changes to protobufs, make sure that you commit the compiled proto files as-well. ",
    "url": "/development/making-changes.html#protobufs",
    "relUrl": "/development/making-changes.html#protobufs"
  },"29": {
    "doc": "Making changes",
    "title": "Dockerfile",
    "content": "When updating the Dockerfile, test building the image using: . $ make docker TAG=\"name:version\" # default TAG=\"pinger:dev\" # Try running the container, should respond with pong $ docker run --rm name:version . ",
    "url": "/development/making-changes.html#dockerfile",
    "relUrl": "/development/making-changes.html#dockerfile"
  },"30": {
    "doc": "Making changes",
    "title": "Check for linting errors",
    "content": "We use golangci-lint. Make sure your changes pass the lint tests. To install golangci-lint, or any other development dependencies, use: . $ make install . To check for linting errors, use: . $ make lint . Some errors can be fixed automatically. To do so, use: . $ make format . So, before committing any change, make sure there are no linting errors in the code. ",
    "url": "/development/making-changes.html#check-for-linting-errors",
    "relUrl": "/development/making-changes.html#check-for-linting-errors"
  },"31": {
    "doc": "Making changes",
    "title": "Commits",
    "content": "Following are the guidelines for committing changes to the repository: . | Break only logical changes into multiple commits. Commits such as “fix typo” or “address review commits” should be squashed into the one logical commit. | Each commit should individually pass tests and lint check. No separate commit should be made to fix these. | We don’t have a defined commit message style for our codebase but the general idea is that the commit should include a heading, a body (if it’s required) and reference to any issue that it might resolve. A good commit message looks something like this: . Short commit heading with gist of changes. Body of commit trying to explain the old behaviour and how this commit changes it for the better. Resolves: #123 Signed-off-by: Contributer &lt;example@contributor.com&gt; . | . ",
    "url": "/development/making-changes.html#commits",
    "relUrl": "/development/making-changes.html#commits"
  },"32": {
    "doc": "Making changes",
    "title": "Making changes",
    "content": " ",
    "url": "/development/making-changes.html",
    "relUrl": "/development/making-changes.html"
  }
}
